{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Laura Chapman\n",
    "# Script for developing statistical tools for Glue\n",
    "# Computes statistics for subsets as well as entire data using compute_statistic\n",
    "# Changed from astropy tables to pandas dataframe\n",
    "\n",
    "# Format data well in a popup using qt\n",
    "# Color code by subset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: W03: w5_psc.vot:11:0: W03: Implicitly generating an ID from a name 'J/ApJ/688/1142/table2' -> 'J_ApJ_688_1142_table2' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:11:0: W03: Implicitly generating an ID from a name 'J/ApJ/688/1142/table2' -> 'J_ApJ_688_1142_table2'\n",
      "WARNING: W03: w5_psc.vot:17:0: W03: Implicitly generating an ID from a name '-ref' -> '_-ref' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:17:0: W03: Implicitly generating an ID from a name '-ref' -> '_-ref'\n",
      "WARNING: W03: w5_psc.vot:18:0: W03: Implicitly generating an ID from a name '-out.max' -> '_-out.max' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:18:0: W03: Implicitly generating an ID from a name '-out.max' -> '_-out.max'\n",
      "WARNING: W03: w5_psc.vot:63:0: W03: Implicitly generating an ID from a name '[3.6]' -> '__3.6_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:63:0: W03: Implicitly generating an ID from a name '[3.6]' -> '__3.6_'\n",
      "WARNING: W03: w5_psc.vot:66:0: W03: Implicitly generating an ID from a name '[4.5]' -> '__4.5_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:66:0: W03: Implicitly generating an ID from a name '[4.5]' -> '__4.5_'\n",
      "WARNING: W03: w5_psc.vot:69:0: W03: Implicitly generating an ID from a name '[5.8]' -> '__5.8_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:69:0: W03: Implicitly generating an ID from a name '[5.8]' -> '__5.8_'\n",
      "WARNING: W03: w5_psc.vot:72:0: W03: Implicitly generating an ID from a name '[8.0]' -> '__8.0_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:72:0: W03: Implicitly generating an ID from a name '[8.0]' -> '__8.0_'\n",
      "WARNING: W03: w5_psc.vot:75:0: W03: Implicitly generating an ID from a name '[24]' -> '__24_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:75:0: W03: Implicitly generating an ID from a name '[24]' -> '__24_'\n",
      "WARNING: W03: w5_psc.vot:81:0: W03: Implicitly generating an ID from a name '[4.5] - [5.8]' -> '__4.5__-__5.8_' [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:81:0: W03: Implicitly generating an ID from a name '[4.5] - [5.8]' -> '__4.5__-__5.8_'\n",
      "WARNING: W03: w5_psc.vot:84:0: W03: Implicitly generating an ID from a name '[5.8] - [8.0]' -> '__5.8__-__8.0_' (suppressing further warnings of this type...) [astropy.io.votable.xmlutil]\n",
      "WARNING:astropy:W03: w5_psc.vot:84:0: W03: Implicitly generating an ID from a name '[5.8] - [8.0]' -> '__5.8__-__8.0_' (suppressing further warnings of this type...)\n"
     ]
    }
   ],
   "source": [
    "# Basic code that imports glue and loads in and links the data\n",
    "\n",
    "import sys\n",
    "from glue.core.data_factories import load_data\n",
    "from glue.core import DataCollection\n",
    "from glue.core.link_helpers import LinkSame\n",
    "from glue.app.qt.application import GlueApplication\n",
    "from glue.viewers.image.qt import ImageViewer\n",
    "from glue_vispy_viewers.volume.volume_viewer import VispyVolumeViewer\n",
    "\n",
    "image_filename='w5.fits'\n",
    "catalog_filename='w5_psc.vot'\n",
    "\n",
    "#load 2 datasets from files\n",
    "catalog = load_data(catalog_filename)\n",
    "image = load_data(image_filename)\n",
    "\n",
    "dc = DataCollection([catalog,image])\n",
    "\n",
    "# link positional information\n",
    "dc.add_link(LinkSame(catalog.id['RAJ2000'], image.id['Right Ascension']))\n",
    "dc.add_link(LinkSame(catalog.id['DEJ2000'], image.id['Declination']))\n",
    "\n",
    "#Create subset based on filament mask\n",
    "ra_state=(image.id['Right Ascension'] > 44) & (image.id['Right Ascension'] < 46)\n",
    "subset_group=dc.new_subset_group('RA_Selection',ra_state)\n",
    "subset_group.style.color = '#0000FF'\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import glue.utils.array as gua\n",
    "import glue.core.data as gcd\n",
    "from astropy.table import Table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Constructs a pandas DataFrame\n",
    "\n",
    "import pandas as pd\n",
    "from pandas import DataFrame\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "w5_psc subset1\n",
      "\n"
     ]
    }
   ],
   "source": [
    "# Defines a subset and runs statistics using compute_statistic for the subset\n",
    "# Saves data using a pandas dataframe called my_pandas_data\n",
    "\n",
    "# Data that subset is pulled from\n",
    "data = dc[0]\n",
    "\n",
    "# Define state and subset\n",
    "state1 = data.id['Jmag'] > 14\n",
    "subset1 = data.new_subset(state1, label='Jmag > 14')\n",
    "\n",
    "# Same arrays as with full data\n",
    "mean_array = []\n",
    "median_array = []\n",
    "min_array = []\n",
    "max_array = []\n",
    "sum_array = []\n",
    "name_array = []\n",
    "tables = []\n",
    "\n",
    "headings = ('mean', 'median', 'minimum', 'maximum', 'sum')\n",
    "\n",
    "print(data.label, 'subset1')\n",
    "print() \n",
    "for j in range (0, len(data.components)):\n",
    "    name = data.components[j].label # Get the name of each component\n",
    "    name_array.append(name) # add to the name array to build the table\n",
    "    mean_array.append(data.compute_statistic('mean', subset1.components[j], subset_state=subset1.subset_state))\n",
    "    median_array.append(data.compute_statistic('median', subset1.components[j], subset_state=subset1.subset_state))       \n",
    "    min_array.append(data.compute_statistic('minimum', subset1.components[j], subset_state=subset1.subset_state))       \n",
    "    max_array.append(data.compute_statistic('maximum', subset1.components[j], subset_state=subset1.subset_state))      \n",
    "    sum_array.append(data.compute_statistic('sum', subset1.components[j], subset_state=subset1.subset_state))        \n",
    "   \n",
    "column_data = np.asarray([mean_array, median_array, min_array, max_array, sum_array]).transpose()\n",
    "\n",
    "my_pandas_data = pd.DataFrame(column_data, index=name_array, columns=headings)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "QApplication instance already exists: <PyQt5.QtWidgets.QApplication object at 0x15103130d8>\n"
     ]
    },
    {
     "ename": "AttributeError",
     "evalue": "'QModelIndex' object has no attribute 'text'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-30-73cb085caee9>\u001b[0m in \u001b[0;36mclicked\u001b[0;34m(self, item)\u001b[0m\n\u001b[1;32m     68\u001b[0m         \u001b[0mWARNING\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mFor\u001b[0m \u001b[0mnow\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mthis\u001b[0m \u001b[0mfunction\u001b[0m \u001b[0monly\u001b[0m \u001b[0mworks\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mcomponent\u001b[0m \u001b[0mnames\u001b[0m \u001b[0mwithin\u001b[0m \u001b[0ma\u001b[0m \u001b[0mdataset\u001b[0m \u001b[0mare\u001b[0m \u001b[0munique\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     69\u001b[0m         '''\n\u001b[0;32m---> 70\u001b[0;31m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mitem\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     71\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     72\u001b[0m \u001b[0;31m#         button=self.sender()\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mAttributeError\u001b[0m: 'QModelIndex' object has no attribute 'text'"
     ]
    },
    {
     "ename": "AttributeError",
     "evalue": "'QModelIndex' object has no attribute 'text'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-30-73cb085caee9>\u001b[0m in \u001b[0;36mclicked\u001b[0;34m(self, item)\u001b[0m\n\u001b[1;32m     68\u001b[0m         \u001b[0mWARNING\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mFor\u001b[0m \u001b[0mnow\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mthis\u001b[0m \u001b[0mfunction\u001b[0m \u001b[0monly\u001b[0m \u001b[0mworks\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mcomponent\u001b[0m \u001b[0mnames\u001b[0m \u001b[0mwithin\u001b[0m \u001b[0ma\u001b[0m \u001b[0mdataset\u001b[0m \u001b[0mare\u001b[0m \u001b[0munique\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     69\u001b[0m         '''\n\u001b[0;32m---> 70\u001b[0;31m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mitem\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     71\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     72\u001b[0m \u001b[0;31m#         button=self.sender()\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mAttributeError\u001b[0m: 'QModelIndex' object has no attribute 'text'"
     ]
    },
    {
     "ename": "SystemExit",
     "evalue": "0",
     "output_type": "error",
     "traceback": [
      "An exception has occurred, use %tb to see the full traceback.\n",
      "\u001b[0;31mSystemExit\u001b[0m\u001b[0;31m:\u001b[0m 0\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/laurachapman/anaconda/envs/glueviz-dev/lib/python3.6/site-packages/IPython/core/interactiveshell.py:2971: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.\n",
      "  warn(\"To exit: use 'exit', 'quit', or Ctrl-D.\", stacklevel=1)\n"
     ]
    }
   ],
   "source": [
    "from PyQt5.QtGui import QIcon, QStandardItemModel, QStandardItem\n",
    "from PyQt5.QtCore import pyqtSlot, QVariant\n",
    "import sys\n",
    "from PyQt5 import QtCore, QtWidgets, QtGui\n",
    "Qt = QtCore.Qt\n",
    "from qtpy.QtWidgets import (QApplication, QLabel, QWidget, QListWidget, QComboBox, QCheckBox, QMessageBox, QListView,\n",
    "                            QVBoxLayout, QPushButton, QGridLayout, QHBoxLayout, QGroupBox, QDialog,  QTableView) \n",
    "\n",
    "class StatsGui(QWidget):\n",
    "    ''' \n",
    "    This class accepts a glue data collection object, and builds an interactive window\n",
    "    to display basic statistics (e.g. mean, median, mode) about each dataset\n",
    "    '''\n",
    "    def __init__(self,dc):\n",
    "        \n",
    "        # Initialize the object as a QWidget\n",
    "        QWidget.__init__(self)\n",
    "    \n",
    "        #Save the datacollection object as an attribute of class StatsGui\n",
    "        self.dc=dc\n",
    "\n",
    "        #Create a dictionary which will keep track of which QPushButtons are selected for each dataset\n",
    "        self.toggle_dictionary = dict((dc.labels[i], np.zeros(len(dc[i].components))) for i in range(0, len(dc)))      \n",
    "        \n",
    "        #Fix the size of the main GUI window (for now)\n",
    "        self.setMinimumSize(800, 600)\n",
    "        self.setMaximumSize(800, 600)\n",
    "        \n",
    "        #Set the title of the main GUI window\n",
    "        self.setWindowTitle('Statistics')\n",
    "        \n",
    "        #################Data Selection Widget#############################\n",
    "        #Set up the viewer that will contain the dropbown data selection menu\n",
    "        self.choose_data = QComboBox(self)\n",
    "        self.choose_data.addItems([\"Choose a dataset\"])\n",
    "        self.choose_data.addItems(dc.labels)\n",
    "        \n",
    "        #Disable the \"Choose a dataset\" button, and move the dropdown menu to center of GUI\n",
    "        self.choose_data.model().item(0).setEnabled(False)\n",
    "        self.choose_data.move(100, 5)\n",
    "        \n",
    "        #When a dataset is changed, call \"selectionchange\" function to update QGridBox widget\n",
    "        self.choose_data.currentIndexChanged.connect(self.selectionchange)    \n",
    "        \n",
    "        #################Set up the QTableView Widget#############################\n",
    "        self.table = QTableView(self)\n",
    "        # Set up the table with the stat headings\n",
    "        self.headings = ('component', 'mean', 'median', 'minimum', 'maximum', 'sum')   \n",
    "        self.data_frame = pd.DataFrame(columns=self.headings)                      \n",
    "        self.model = pandasModel(self.data_frame)\n",
    "\n",
    "        self.table.setModel(self.model)\n",
    "        self.table.setShowGrid(False)          \n",
    "        \n",
    "        #Move the table widget to the bottom of the GUI window\n",
    "        self.table.setGeometry(50, 250, 700, 300) \n",
    "        \n",
    "        # Set up the list to choose components from\n",
    "        self.list = QListView(self)\n",
    "        self.list.move(400, 5)\n",
    "        \n",
    "        \n",
    "    def clicked(self, item):\n",
    "        '''\n",
    "        This function is activated whenever a component button is pressed inside the QGridLayout.\n",
    "        Each time it is called, it will determine which QPushButton was pressed or unpressed.\n",
    "        It will keep track of toggle state of all buttons for all datasets inside the toggle_dictionary variable\n",
    "        WARNING: For now, this function only works if component names within a dataset are unique\n",
    "        '''\n",
    "        print(item.text())\n",
    "        \n",
    "#         button=self.sender()\n",
    "        \n",
    "#         #Check to make sure the button is indeed a QPushButton\n",
    "#         if isinstance(button, QPushButton):\n",
    "            \n",
    "#             #If the button is clicked, figure out which one, and log the \"on\" state in toggle_dictionary\n",
    "#             #If the button is clicked, calculate its statistics and add a row to the table\n",
    "#             if button.isChecked():\n",
    "#                 comp_i = np.where(np.asarray(dc[self.data_index].components).astype(str) == button.text())[0][0]                \n",
    "#                 self.toggle_dictionary[dc.labels[self.data_index]][comp_i] = 1\n",
    "                \n",
    "#                 # Run statistics\n",
    "                \n",
    "#                 # Set up the statistical arrays and clear each\n",
    "#                 data_array = []\n",
    "#                 name_array = []\n",
    "#                 mean_array = []\n",
    "#                 median_array = []\n",
    "#                 min_array = []\n",
    "#                 max_array = []\n",
    "#                 sum_array = []\n",
    "                  \n",
    "#                 # Retrive the statistical data and add it to the arrays\n",
    "#                 data_name = self.dc[self.data_index].label\n",
    "#                 data_array.append(data_name)\n",
    "#                 name = self.dc[self.data_index].components[comp_i].label\n",
    "#                 name_array.append(name) # add to the name array to build the table\n",
    "#                 mean_array.append(self.dc[self.data_index].compute_statistic('mean', self.dc[self.data_index].components[comp_i]))\n",
    "#                 median_array.append(self.dc[self.data_index].compute_statistic('median', self.dc[self.data_index].components[comp_i]))       \n",
    "#                 min_array.append(self.dc[self.data_index].compute_statistic('minimum', self.dc[self.data_index].components[comp_i]))      \n",
    "#                 max_array.append(self.dc[self.data_index].compute_statistic('maximum', self.dc[self.data_index].components[comp_i]))     \n",
    "#                 sum_array.append(self.dc[self.data_index].compute_statistic('sum', self.dc[self.data_index].components[comp_i]))             \n",
    "                       \n",
    "#                 column_data = np.asarray([name_array, mean_array, median_array, min_array, max_array, sum_array]).transpose()                \n",
    "            \n",
    "#                 self.data_frame = pd.DataFrame(column_data, index=data_array, columns=self.headings)\n",
    "                \n",
    "# # this code attempted to add and remove rows into the pandas model- not functional yet             \n",
    "# #                 try: \n",
    "# #                     self.model\n",
    "# #                     self.model.insertRow(0)\n",
    "                    \n",
    "# #                 except:\n",
    "# #                     self.model = pandasModel(self.data_frame)                    \n",
    "# #                     self.table.setModel(self.model)\n",
    "\n",
    "#                 self.model = pandasModel(self.data_frame)                    \n",
    "#                 self.table.setModel(self.model)\n",
    "\n",
    "#             #If a button is clicked off, figure out which one, and log the \"off\" state in toggle_dictionary\n",
    "#             #I the button is clicked off, remove that row from the table\n",
    "#             else:\n",
    "#                 index = np.where(np.asarray(dc[self.data_index].components).astype(str) == button.text())[0]\n",
    "#                 self.toggle_dictionary[dc.labels[self.data_index]][index] = 0\n",
    "#                 # Attempt to remove the row\n",
    "# #                 self.model.removeRow(0)\n",
    "                \n",
    "    def selectionchange(self, i):\n",
    "        '''\n",
    "        This function is called whenever the user selects a new dataset inside QComboBox\n",
    "        Its job is to replace the QPushButtons in QGridLayout with the components corresponding to the dataset.\n",
    "        If a QGridLayout already exists, it removes all the old QPushButtons before adding new ones\n",
    "        '''        \n",
    "        \n",
    "        #\"Choose a dataset\" counts as a line in QComboBox, so we must subtract one to start from index zero\n",
    "        self.data_index = i-1\n",
    "        model = QStandardItemModel()\n",
    "        \n",
    "        for i in range (0, len(dc[self.data_index].components)):\n",
    "                \n",
    "            #Set the text on the list item to the component name\n",
    "            label=str(self.dc[self.data_index].components[i])\n",
    "                \n",
    "            item = QStandardItem(label)\n",
    " \n",
    "            # add a checkbox to it\n",
    "            item.setCheckable(True)\n",
    " \n",
    "            # Add the item to the model\n",
    "            model.appendRow(item)\n",
    " \n",
    "        # Apply the model to the list view\n",
    "        self.list.setModel(model) \n",
    "        \n",
    "        # Connect with the clicked function\n",
    "        self.list.clicked.connect(self.clicked)\n",
    "    \n",
    "class pandasModel(QtCore.QAbstractTableModel):\n",
    "    # Set up the data in a form that allows it to be added to qt widget\n",
    "    # Write a function that allows data to be updated ie add and remove rows\n",
    "    def __init__(self, df, parent=None):\n",
    "        QtCore.QAbstractTableModel.__init__(self, parent)\n",
    "        self.data_frame = df\n",
    "        super(pandasModel, self).__init__(parent)      \n",
    "\n",
    "    def rowCount(self, parent=None):\n",
    "        return len(self.data_frame.values)\n",
    "\n",
    "    def columnCount(self, parent=None):\n",
    "        return self.data_frame.columns.size\n",
    "\n",
    "    def data(self, index, role=Qt.DisplayRole):\n",
    "        if index.isValid():\n",
    "            if role == Qt.DisplayRole:\n",
    "                return QVariant(str(\n",
    "                    self.data_frame.values[index.row()][index.column()]))\n",
    "        return QVariant()\n",
    "    \n",
    "    def headerData(self, col, orientation, role):\n",
    "        if orientation == Qt.Horizontal and role == Qt.DisplayRole:\n",
    "            return QVariant(self.data_frame.columns[col])\n",
    "        if orientation == Qt.Vertical and role == Qt.DisplayRole:\n",
    "            return QVariant(self.data_frame.index[col])\n",
    "        return QVariant()  \n",
    "    \n",
    " # Trying to add functions that allow for rows to be removed and inserted into the pandas model\n",
    "#     def removeRow(self, position, rows=1, index=QModelIndex()):\n",
    "#         self.beginRemoveRows(QModelIndex(), position, position + rows - 1)       \n",
    "#         self.data_frame = self.data_frame[:position] + self.items[position + rows:]\n",
    "#         self.endRemoveRows()\n",
    "\n",
    "#         return True\n",
    "\n",
    "#     def insertRows(self, position, rows=1, index=QModelIndex()):\n",
    "#         self.beginInsertRows(QModelIndex(), position, position + rows - 1)\n",
    "#         for row in range(rows):\n",
    "#             self.data_frame.insert(position, 0, [2,3,4,5,6])\n",
    "#             self.added+=1\n",
    "#         self.endInsertRows()\n",
    "#         return True   \n",
    "    \n",
    "app = QApplication.instance()\n",
    "if app is None:\n",
    "    app = QApplication(sys.argv)\n",
    "else:\n",
    "    print('QApplication instance already exists: %s' % str(app))\n",
    "ex = StatsGui(dc)\n",
    "ex.show()\n",
    "sys.exit(app.exec_())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Things to implement\n",
    "add the name of the data set to the component\n",
    "sort by maximum, minimum etc\n",
    "make it scroll if there are too many buttons\n",
    "have a drop down menu to select components that you want to turn into buttons\n",
    "have a button that says select all or deselect all\n",
    "show subsets as a button\n",
    "have a list of components and select from a list instead of buttons\n",
    "complete working insert row and remove row functionality when user clicks buttons\n",
    "add in data subsets\n",
    "color code table by data/subset?\n",
    "export to file button\n",
    "advanced mode that allows user to pick what stats to calculate'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "class myListWidget(QListWidget):\n",
    "\n",
    "   def Clicked(self,item):\n",
    "      print(item.text())\n",
    "\t\t\n",
    "def main():\n",
    "   app = QApplication(sys.argv)\n",
    "   listWidget = myListWidget()\n",
    "\t\n",
    "   #Resize width and height\n",
    "   listWidget.resize(300,120)\n",
    "\t\n",
    "   listWidget.addItem(\"Item 1\"); \n",
    "   listWidget.addItem(\"Item 2\");\n",
    "   listWidget.addItem(\"Item 3\");\n",
    "   listWidget.addItem(\"Item 4\");\n",
    "\t\n",
    "   listWidget.setWindowTitle('PyQT QListwidget Demo')\n",
    "   listWidget.itemClicked.connect(listWidget.Clicked)\n",
    "   \n",
    "   listWidget.show()\n",
    "   sys.exit(app.exec_())\n",
    "\t\n",
    "if __name__ == '__main__':\n",
    "   main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class QModelIndex in module PyQt5.QtCore:\n",
      "\n",
      "class QModelIndex(sip.simplewrapper)\n",
      " |  QModelIndex()\n",
      " |  QModelIndex(QModelIndex)\n",
      " |  QModelIndex(QPersistentModelIndex)\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      QModelIndex\n",
      " |      sip.simplewrapper\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __eq__(self, value, /)\n",
      " |      Return self==value.\n",
      " |  \n",
      " |  __ge__(self, value, /)\n",
      " |      Return self>=value.\n",
      " |  \n",
      " |  __gt__(self, value, /)\n",
      " |      Return self>value.\n",
      " |  \n",
      " |  __hash__(self, /)\n",
      " |      Return hash(self).\n",
      " |  \n",
      " |  __le__(self, value, /)\n",
      " |      Return self<=value.\n",
      " |  \n",
      " |  __lt__(self, value, /)\n",
      " |      Return self<value.\n",
      " |  \n",
      " |  __ne__(self, value, /)\n",
      " |      Return self!=value.\n",
      " |  \n",
      " |  child(...)\n",
      " |      child(self, int, int) -> QModelIndex\n",
      " |  \n",
      " |  column(...)\n",
      " |      column(self) -> int\n",
      " |  \n",
      " |  data(...)\n",
      " |      data(self, role: int = Qt.DisplayRole) -> Any\n",
      " |  \n",
      " |  flags(...)\n",
      " |      flags(self) -> Qt.ItemFlags\n",
      " |  \n",
      " |  internalId(...)\n",
      " |      internalId(self) -> int\n",
      " |  \n",
      " |  internalPointer(...)\n",
      " |      internalPointer(self) -> object\n",
      " |  \n",
      " |  isValid(...)\n",
      " |      isValid(self) -> bool\n",
      " |  \n",
      " |  model(...)\n",
      " |      model(self) -> QAbstractItemModel\n",
      " |  \n",
      " |  parent(...)\n",
      " |      parent(self) -> QModelIndex\n",
      " |  \n",
      " |  row(...)\n",
      " |      row(self) -> int\n",
      " |  \n",
      " |  sibling(...)\n",
      " |      sibling(self, int, int) -> QModelIndex\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  __weakref__\n",
      " |      list of weak references to the object (if defined)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from sip.simplewrapper:\n",
      " |  \n",
      " |  __init__(self, /, *args, **kwargs)\n",
      " |      Initialize self.  See help(type(self)) for accurate signature.\n",
      " |  \n",
      " |  __new__(*args, **kwargs) from sip.wrappertype\n",
      " |      Create and return a new object.  See help(type) for accurate signature.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from sip.simplewrapper:\n",
      " |  \n",
      " |  __dict__\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(QtCore.QModelIndex)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from PyQt5.QtGui import *\n",
    "import sys\n",
    "import types\n",
    "\n",
    "class MainFrame(QWidget):\n",
    "    def __init__(self):\n",
    "        QWidget.__init__(self)\n",
    "\n",
    "        tree = {'root': {\n",
    "                    \"1\": [\"A\", \"B\", \"C\"],\n",
    "                    \"2\": {\n",
    "                        \"2-1\": [\"G\", \"H\", \"I\"],\n",
    "                        \"2-2\": [\"J\", \"K\", \"L\"]},\n",
    "                    \"3\": [\"D\", \"E\", \"F\"]}\n",
    "        }\n",
    "\n",
    "        self.tree = QTreeView(self)\n",
    "        layout = QHBoxLayout(self)\n",
    "        layout.addWidget(self.tree)\n",
    "\n",
    "        root_model = QStandardItemModel()\n",
    "        self.tree.setModel(root_model)\n",
    "        self._populateTree(tree, root_model.invisibleRootItem())\n",
    "        type(root_model.invisibleRootItem())\n",
    "\n",
    "    def _populateTree(self, children, parent):\n",
    "#         for child in sorted(children):\n",
    "#             type(children)\n",
    "#             child_item = QStandardItem(child)\n",
    "#             parent.appendRow(child_item)\n",
    "#             if isinstance(children, types.DictType):\n",
    "#                 self._populateTree(children[child], child_item)\n",
    "        pass\n",
    "\n",
    "    \n",
    "app = QApplication.instance()\n",
    "if app is None:\n",
    "    app = QApplication(sys.argv)\n",
    "else:\n",
    "    print('QApplication instance already exists: %s' % str(app))\n",
    "ex = MainFrame()\n",
    "ex.show()\n",
    "sys.exit(app.exec_())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "type(children)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class CheckState in module PyQt5.QtCore:\n",
      "\n",
      "class CheckState(builtins.int)\n",
      " |  int(x=0) -> integer\n",
      " |  int(x, base=10) -> integer\n",
      " |  \n",
      " |  Convert a number or string to an integer, or return 0 if no arguments\n",
      " |  are given.  If x is a number, return x.__int__().  For floating point\n",
      " |  numbers, this truncates towards zero.\n",
      " |  \n",
      " |  If x is not a number or if base is given, then x must be a string,\n",
      " |  bytes, or bytearray instance representing an integer literal in the\n",
      " |  given base.  The literal can be preceded by '+' or '-' and be surrounded\n",
      " |  by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\n",
      " |  Base 0 means to interpret the base from the string as an integer literal.\n",
      " |  >>> int('0b100', base=0)\n",
      " |  4\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      CheckState\n",
      " |      builtins.int\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  __reduce__ = _pickle_enum(...)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors defined here:\n",
      " |  \n",
      " |  __dict__\n",
      " |      dictionary for instance variables (if defined)\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from builtins.int:\n",
      " |  \n",
      " |  __abs__(self, /)\n",
      " |      abs(self)\n",
      " |  \n",
      " |  __add__(self, value, /)\n",
      " |      Return self+value.\n",
      " |  \n",
      " |  __and__(self, value, /)\n",
      " |      Return self&value.\n",
      " |  \n",
      " |  __bool__(self, /)\n",
      " |      self != 0\n",
      " |  \n",
      " |  __ceil__(...)\n",
      " |      Ceiling of an Integral returns itself.\n",
      " |  \n",
      " |  __divmod__(self, value, /)\n",
      " |      Return divmod(self, value).\n",
      " |  \n",
      " |  __eq__(self, value, /)\n",
      " |      Return self==value.\n",
      " |  \n",
      " |  __float__(self, /)\n",
      " |      float(self)\n",
      " |  \n",
      " |  __floor__(...)\n",
      " |      Flooring an Integral returns itself.\n",
      " |  \n",
      " |  __floordiv__(self, value, /)\n",
      " |      Return self//value.\n",
      " |  \n",
      " |  __format__(...)\n",
      " |      default object formatter\n",
      " |  \n",
      " |  __ge__(self, value, /)\n",
      " |      Return self>=value.\n",
      " |  \n",
      " |  __getattribute__(self, name, /)\n",
      " |      Return getattr(self, name).\n",
      " |  \n",
      " |  __getnewargs__(...)\n",
      " |  \n",
      " |  __gt__(self, value, /)\n",
      " |      Return self>value.\n",
      " |  \n",
      " |  __hash__(self, /)\n",
      " |      Return hash(self).\n",
      " |  \n",
      " |  __index__(self, /)\n",
      " |      Return self converted to an integer, if self is suitable for use as an index into a list.\n",
      " |  \n",
      " |  __int__(self, /)\n",
      " |      int(self)\n",
      " |  \n",
      " |  __invert__(self, /)\n",
      " |      ~self\n",
      " |  \n",
      " |  __le__(self, value, /)\n",
      " |      Return self<=value.\n",
      " |  \n",
      " |  __lshift__(self, value, /)\n",
      " |      Return self<<value.\n",
      " |  \n",
      " |  __lt__(self, value, /)\n",
      " |      Return self<value.\n",
      " |  \n",
      " |  __mod__(self, value, /)\n",
      " |      Return self%value.\n",
      " |  \n",
      " |  __mul__(self, value, /)\n",
      " |      Return self*value.\n",
      " |  \n",
      " |  __ne__(self, value, /)\n",
      " |      Return self!=value.\n",
      " |  \n",
      " |  __neg__(self, /)\n",
      " |      -self\n",
      " |  \n",
      " |  __new__(*args, **kwargs) from builtins.type\n",
      " |      Create and return a new object.  See help(type) for accurate signature.\n",
      " |  \n",
      " |  __or__(self, value, /)\n",
      " |      Return self|value.\n",
      " |  \n",
      " |  __pos__(self, /)\n",
      " |      +self\n",
      " |  \n",
      " |  __pow__(self, value, mod=None, /)\n",
      " |      Return pow(self, value, mod).\n",
      " |  \n",
      " |  __radd__(self, value, /)\n",
      " |      Return value+self.\n",
      " |  \n",
      " |  __rand__(self, value, /)\n",
      " |      Return value&self.\n",
      " |  \n",
      " |  __rdivmod__(self, value, /)\n",
      " |      Return divmod(value, self).\n",
      " |  \n",
      " |  __repr__(self, /)\n",
      " |      Return repr(self).\n",
      " |  \n",
      " |  __rfloordiv__(self, value, /)\n",
      " |      Return value//self.\n",
      " |  \n",
      " |  __rlshift__(self, value, /)\n",
      " |      Return value<<self.\n",
      " |  \n",
      " |  __rmod__(self, value, /)\n",
      " |      Return value%self.\n",
      " |  \n",
      " |  __rmul__(self, value, /)\n",
      " |      Return value*self.\n",
      " |  \n",
      " |  __ror__(self, value, /)\n",
      " |      Return value|self.\n",
      " |  \n",
      " |  __round__(...)\n",
      " |      Rounding an Integral returns itself.\n",
      " |      Rounding with an ndigits argument also returns an integer.\n",
      " |  \n",
      " |  __rpow__(self, value, mod=None, /)\n",
      " |      Return pow(value, self, mod).\n",
      " |  \n",
      " |  __rrshift__(self, value, /)\n",
      " |      Return value>>self.\n",
      " |  \n",
      " |  __rshift__(self, value, /)\n",
      " |      Return self>>value.\n",
      " |  \n",
      " |  __rsub__(self, value, /)\n",
      " |      Return value-self.\n",
      " |  \n",
      " |  __rtruediv__(self, value, /)\n",
      " |      Return value/self.\n",
      " |  \n",
      " |  __rxor__(self, value, /)\n",
      " |      Return value^self.\n",
      " |  \n",
      " |  __sizeof__(...)\n",
      " |      Returns size in memory, in bytes\n",
      " |  \n",
      " |  __str__(self, /)\n",
      " |      Return str(self).\n",
      " |  \n",
      " |  __sub__(self, value, /)\n",
      " |      Return self-value.\n",
      " |  \n",
      " |  __truediv__(self, value, /)\n",
      " |      Return self/value.\n",
      " |  \n",
      " |  __trunc__(...)\n",
      " |      Truncating an Integral returns itself.\n",
      " |  \n",
      " |  __xor__(self, value, /)\n",
      " |      Return self^value.\n",
      " |  \n",
      " |  bit_length(...)\n",
      " |      int.bit_length() -> int\n",
      " |      \n",
      " |      Number of bits necessary to represent self in binary.\n",
      " |      >>> bin(37)\n",
      " |      '0b100101'\n",
      " |      >>> (37).bit_length()\n",
      " |      6\n",
      " |  \n",
      " |  conjugate(...)\n",
      " |      Returns self, the complex conjugate of any int.\n",
      " |  \n",
      " |  from_bytes(...) from sip.enumtype\n",
      " |      int.from_bytes(bytes, byteorder, *, signed=False) -> int\n",
      " |      \n",
      " |      Return the integer represented by the given array of bytes.\n",
      " |      \n",
      " |      The bytes argument must be a bytes-like object (e.g. bytes or bytearray).\n",
      " |      \n",
      " |      The byteorder argument determines the byte order used to represent the\n",
      " |      integer.  If byteorder is 'big', the most significant byte is at the\n",
      " |      beginning of the byte array.  If byteorder is 'little', the most\n",
      " |      significant byte is at the end of the byte array.  To request the native\n",
      " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n",
      " |      \n",
      " |      The signed keyword-only argument indicates whether two's complement is\n",
      " |      used to represent the integer.\n",
      " |  \n",
      " |  to_bytes(...)\n",
      " |      int.to_bytes(length, byteorder, *, signed=False) -> bytes\n",
      " |      \n",
      " |      Return an array of bytes representing an integer.\n",
      " |      \n",
      " |      The integer is represented using length bytes.  An OverflowError is\n",
      " |      raised if the integer is not representable with the given number of\n",
      " |      bytes.\n",
      " |      \n",
      " |      The byteorder argument determines the byte order used to represent the\n",
      " |      integer.  If byteorder is 'big', the most significant byte is at the\n",
      " |      beginning of the byte array.  If byteorder is 'little', the most\n",
      " |      significant byte is at the end of the byte array.  To request the native\n",
      " |      byte order of the host system, use `sys.byteorder' as the byte order value.\n",
      " |      \n",
      " |      The signed keyword-only argument determines whether two's complement is\n",
      " |      used to represent the integer.  If signed is False and a negative integer\n",
      " |      is given, an OverflowError is raised.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from builtins.int:\n",
      " |  \n",
      " |  denominator\n",
      " |      the denominator of a rational number in lowest terms\n",
      " |  \n",
      " |  imag\n",
      " |      the imaginary part of a complex number\n",
      " |  \n",
      " |  numerator\n",
      " |      the numerator of a rational number in lowest terms\n",
      " |  \n",
      " |  real\n",
      " |      the real part of a complex number\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(Qt.CheckState)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "help(isinstance)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
